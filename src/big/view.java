/*
 * SPDXVersion: SPDX-1.1
 * Creator: Person: Nuno Brito (nuno.brito@triplecheck.de)
 * Creator: Organization: TripleCheck (contact@triplecheck.de)
 * Created: 2014-10-08T00:00:00Z
 * LicenseName: EUPL-1.1-without-appendix
 * FileName: view.java
 * FileType: SOURCE
 * FileCopyrightText: <text> Copyright 2013 Nuno Brito, TripleCheck </text>
 * FileComment: <text> The GUI for users to view the contents of big zips.
   </text>
 */

package big;

import java.awt.Color;
import java.awt.Toolkit;
import java.awt.event.KeyEvent;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.net.URL;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.UIManager;
import javax.swing.UnsupportedLookAndFeelException;
import javax.swing.filechooser.FileNameExtensionFilter;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;

/**
 *
 * @author Nuno Brito, 08th of October 2014 in Darmstadt, Germany.
 */
public class view extends javax.swing.JFrame {

    
    // are we testing the software or not?
    boolean automaticMode = false;
   
    
    // the settings for the last folder/file that was open
    static final String lastFolderFilename = "last-folder.txt";
    static final File lastFolder = new File(lastFolderFilename);
    private int counter;
    private ArchiveBIG big;
    private DefaultTreeModel model;
    private DefaultMutableTreeNode root;
    private final String searchTerm = "Search files..";
      
    
    // we use these two variables for the file filtering
    private String keywordSearch;
    private Boolean hasKeywordSearch = false;
    
    /**
     * Creates new form view
     */
    public view() {
        initComponents();
        
         // adopt the default user interface menus and buttons
        try {
            UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
        } catch (ClassNotFoundException ex) {} catch (IllegalAccessException ex) {
        } catch (InstantiationException ex) {
        } catch (UnsupportedLookAndFeelException ex) {
        }
        
        // get the window icon working
        URL imgURL = this.getClass().getResource("logo.png");
        setIconImage(Toolkit.getDefaultToolkit().getImage(imgURL));
        
        this.setTitle("bigzip");
        
        // place the frame on the middle of the screen
        setLocationRelativeTo(null);
        
        // change the background to full white
        getContentPane().setBackground( Color.WHITE );
        
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jSplitPane1 = new javax.swing.JSplitPane();
        panelWest = new javax.swing.JScrollPane();
        tree = new javax.swing.JTree();
        panelEast = new javax.swing.JPanel();
        jScrollPane2 = new javax.swing.JScrollPane();
        jPanel3 = new javax.swing.JPanel();
        text = new javax.swing.JEditorPane();
        search = new javax.swing.JTextField();
        buttonSave = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jSplitPane1.setBorder(null);
        jSplitPane1.setDividerLocation(200);

        panelWest.setAutoscrolls(true);
        panelWest.setPreferredSize(new java.awt.Dimension(172, 362));

        tree.setBorder(javax.swing.BorderFactory.createEmptyBorder(3, 2, 5, 5));
        javax.swing.tree.DefaultMutableTreeNode treeNode1 = new javax.swing.tree.DefaultMutableTreeNode("root");
        tree.setModel(new javax.swing.tree.DefaultTreeModel(treeNode1));
        tree.setAutoscrolls(true);
        tree.setLargeModel(true);
        tree.setRootVisible(false);
        tree.setRowHeight(18);
        tree.setToggleClickCount(1);
        tree.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                treeeventTreeMouseClicked(evt);
            }
        });
        panelWest.setViewportView(tree);

        jSplitPane1.setLeftComponent(panelWest);

        jScrollPane2.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);
        jScrollPane2.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);

        text.setEditable(false);
        text.setMinimumSize(new java.awt.Dimension(10, 23));
        text.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                textFocusGained(evt);
            }
            public void focusLost(java.awt.event.FocusEvent evt) {
                textFocusLost(evt);
            }
        });
        text.addPropertyChangeListener(new java.beans.PropertyChangeListener() {
            public void propertyChange(java.beans.PropertyChangeEvent evt) {
                textPropertyChange(evt);
            }
        });
        text.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyTyped(java.awt.event.KeyEvent evt) {
                textKeyTyped(evt);
            }
        });

        javax.swing.GroupLayout jPanel3Layout = new javax.swing.GroupLayout(jPanel3);
        jPanel3.setLayout(jPanel3Layout);
        jPanel3Layout.setHorizontalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(text, javax.swing.GroupLayout.DEFAULT_SIZE, 475, Short.MAX_VALUE)
        );
        jPanel3Layout.setVerticalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(text, javax.swing.GroupLayout.DEFAULT_SIZE, 358, Short.MAX_VALUE)
        );

        jScrollPane2.setViewportView(jPanel3);

        search.setFont(new java.awt.Font("Arial", 0, 14)); // NOI18N
        search.setText("Search..");
        search.setMargin(new java.awt.Insets(2, 8, 2, 2));
        search.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                searchFocusGained(evt);
            }
            public void focusLost(java.awt.event.FocusEvent evt) {
                searchFocusLost(evt);
            }
        });
        search.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                searchdoSearchKeypress(evt);
            }
            public void keyReleased(java.awt.event.KeyEvent evt) {
                searchdoSearch(evt);
            }
        });

        buttonSave.setIcon(new javax.swing.ImageIcon(getClass().getResource("/big/disk-black.png"))); // NOI18N
        buttonSave.setBorder(javax.swing.BorderFactory.createEtchedBorder());
        buttonSave.setEnabled(false);
        buttonSave.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                buttonSaveActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout panelEastLayout = new javax.swing.GroupLayout(panelEast);
        panelEast.setLayout(panelEastLayout);
        panelEastLayout.setHorizontalGroup(
            panelEastLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 469, Short.MAX_VALUE)
            .addGroup(panelEastLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(search)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(buttonSave, javax.swing.GroupLayout.PREFERRED_SIZE, 35, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );
        panelEastLayout.setVerticalGroup(
            panelEastLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(panelEastLayout.createSequentialGroup()
                .addGap(4, 4, 4)
                .addGroup(panelEastLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(search, javax.swing.GroupLayout.DEFAULT_SIZE, 34, Short.MAX_VALUE)
                    .addComponent(buttonSave, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jScrollPane2))
        );

        jSplitPane1.setRightComponent(panelEast);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jSplitPane1)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jSplitPane1)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void treeeventTreeMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_treeeventTreeMouseClicked
        getSelectedTreeNode();
    }//GEN-LAST:event_treeeventTreeMouseClicked

    private void textFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_textFocusGained

    }//GEN-LAST:event_textFocusGained

    private void textFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_textFocusLost

    }//GEN-LAST:event_textFocusLost

    private void textPropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_textPropertyChange

    }//GEN-LAST:event_textPropertyChange

    private void textKeyTyped(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_textKeyTyped

    }//GEN-LAST:event_textKeyTyped

    private void searchFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_searchFocusGained
        doSearchMouseClicked();
    }//GEN-LAST:event_searchFocusGained

    private void searchFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_searchFocusLost
       // reset back to the default value when empty
       searchReset();
    }//GEN-LAST:event_searchFocusLost

    private void searchdoSearchKeypress(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_searchdoSearchKeypress
         performSearch(evt);
    }//GEN-LAST:event_searchdoSearchKeypress

    private void searchdoSearch(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_searchdoSearch
         performSearch(evt);
    }//GEN-LAST:event_searchdoSearch

    private void buttonSaveActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buttonSaveActionPerformed
        saveSelectedFile();
    }//GEN-LAST:event_buttonSaveActionPerformed

     /**
     * Shows the dialog to allow selecting a folder 
     */
    public void chooseFolder(){
        
        // read the last folder that was chosen
        File lastFile = getLastFile();
        
        
        JFileChooser fc = new JFileChooser();
            fc.setMultiSelectionEnabled(false);
            
            FileNameExtensionFilter filter = new FileNameExtensionFilter(
                "BIG archive", "big");
            
            
            fc.setFileFilter(filter);
            // only show directories
            fc.setFileSelectionMode(JFileChooser.OPEN_DIALOG);
            
            // check if the last used folder still exists
            if(lastFile.exists())
            if((lastFile.getParentFile().exists())){
                // start from the previous folder if possible
//                fc.setCurrentDirectory(lastFile.getParentFile());
                fc.setSelectedFile(lastFile);
            }

        fc.setDialogTitle("Open directory");
        // open up the dialog
        if (fc.showOpenDialog(null) != JFileChooser.APPROVE_OPTION) {
            System.exit(0);
            return;
        }
        
        // write this name to the file on disk
        utils.files.SaveStringToFile(lastFolder, fc.getSelectedFile().getAbsolutePath());
    }
    
    
    /**
     * @param args the command line arguments
     */
    public static void main(final String args[]) {
        
        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                view thisView = new view();
                processCommandLine(args, thisView);
                // opens a big zip as first operation
                thisView.setVisible(true);
                thisView.openFile();
            }
        });
    }

    /**
     * Handle possible command line parameters when available.
     * @param args 
     */
     private static void processCommandLine(final String[] args, view thisView) {
         // empty parameters?
         if(args.length == 0){
             // nothing more to do
             return;
         }
         
         // create a file pointer
         File thisFile = new File(args[0]);

         // check if the mentioned file exists or not
         if(thisFile.exists() == false || thisFile.isDirectory()){
             // no need to continue
             System.out.println("V360: Failed to load: " + thisFile.getAbsolutePath());
             return;
         }
         
         // initialize the automatic mode
         thisView.automaticMode = true;
         utils.files.SaveStringToFile(lastFolder, thisFile.getAbsolutePath());

         
         // get the first parameter and use it as starting step
         System.out.println("Loading from command line: " 
                 + thisFile.getAbsolutePath());
         
     }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton buttonSave;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JSplitPane jSplitPane1;
    private javax.swing.JPanel panelEast;
    private javax.swing.JScrollPane panelWest;
    private javax.swing.JTextField search;
    private javax.swing.JEditorPane text;
    private javax.swing.JTree tree;
    // End of variables declaration//GEN-END:variables

    /**
     * Opens up the "File Open" dialog to choose a big zip.
     */
    private void openFile() {
        // show the open file dialog
        if(automaticMode == false){
            chooseFolder();
        }
        // show the file contents
        displayContents();
    }

    /**
     * Returns a file pointer to the last file that was used
     * @return The file pointer on disk or null if nothing was selected.
     */
    public File getLastFile(){
    // read the last folder that was chosen
        String lastFileText = utils.files.readAsString(lastFolder);
        File lastFile = new File(lastFileText);
        return lastFile;
    }
    
    /**
     * Get the index file associated with the big archive
     * @return 
     */
     public File getLastFileIndex(){
    // read the last folder that was chosen
        String lastFileText = utils.files.readAsString(lastFolder);
        File lastFile = new File(lastFileText);
        return lastFile;
    }
    
    /**
     * Creates a treeview with the contents from the big file
     */
    private void displayContents() {
        // get the last file that was open
        File lastFile = getLastFile();
        // no need to continue if the file is null for some odd reason
        if(lastFile == null){
            return;
        }
        
        // open up the big archive
        big = new ArchiveBIG(lastFile);
        
        File indexFile = big.getFileIndex();
        // check if the file for index does exist
        if(indexFile == null){
            return;
        }
        
        doSettings();
        processLines(big);
        doFinish();
    }

    /**
     * Extract the data that we find interesting to show
     * @param line 
     */
    private void processLine(final String line) {
       // we expect a line on the following format:
       //000000026039957 4b7b96a4c76fb230ac055cad145dbbfb346a5663 /github.com/trankas/opentesarenapp/WinArena/World.cpp
       
        // cut the string into pieces
        final String 
                signature = line.substring(16, 56),
                filename  = line.substring(57);
        
        // do we have filtering active?
        if(hasKeywordSearch){
            // does the file name contain part of what we are looking for?
            if(filename.toLowerCase().contains(keywordSearch)==false){
                // nope, just keep moving to the next line
                return;
            }
        }
        
        // convert the long number
        final Long position = Long.parseLong(line.substring(00, 15));
        // create the node
        final BigNode node = new BigNode(position, signature, filename);
        
        // add it up to the tree view listing
        root.add(new DefaultMutableTreeNode(node));
        counter++;
    }

    /**
     * The small settings related to the file being processed
     */
    private void doSettings() {
        File file = getLastFile();
        this.setTitle(file.getName());
        // get the tree object
        model = (DefaultTreeModel)tree.getModel();
        root = (DefaultMutableTreeNode)model.getRoot();
        
        // reset the treeview and counter
        root.removeAllChildren();
        model.setRoot(root);
        counter = 0;
        // this is needed to ensure we get line-wrapping
        jScrollPane2.setViewportView(text);
        // initialize the search bar
        if(hasKeywordSearch == false){
            search.setText(searchTerm);
        }
        
    }

    /**
     * Process the lines inside our archive
     * @param big 
     */
    private void processLines(ArchiveBIG big) {
        // list the contents
        BufferedReader reader;
        try {
            // open up the index file
            FileReader fileReader = new FileReader(big.getFileIndex());
            reader = new BufferedReader(fileReader);
            // avoid the signature line
            reader.readLine();
            // read the first line of data
            String line = reader.readLine();
            
            // iterate all lines?
            while (line != null) {
                // get this line of data handled
                processLine(line);
                // read the line afterwards
                line = reader.readLine();
            } 
        
            // close the streams
            reader.close();
            fileReader.close();
            
        }catch (Exception e){
            System.err.println("V458 - Something went wrong while reading the archive");
        }
        
    }

    /**
     * Final settings after loading a big archive
     */
    private void doFinish() {
        // change the window title
        this.setTitle(big.getFile().getName() 
                + " ("
                + utils.text.pluralize(counter, "file")
                + ", "
                + utils.files.humanReadableSize(big.getFile().length())
                + ")"
        );
        
        // reload the treeview
        model.reload(root);
        big.close();
    }

    /**
     * This method is triggered when the user clicks on the tree view
     */
    private synchronized void getSelectedTreeNode() {
        DefaultMutableTreeNode treeNode = (DefaultMutableTreeNode) tree.getSelectionPath().getLastPathComponent();
        if(treeNode == null){
            buttonSave.setEnabled(false);
            return;
        }
        // get the associated object
        BigNode result = (BigNode) treeNode.getUserObject();
        buttonSave.setEnabled(true);
            
        processClick(result);
    }

    /**
     * Process the result from he click on the treeview
     * @param result 
     */
    private void processClick(final BigNode result) {
        // avoid null results
        if(result == null){
            return;
        }
        
        // extract the file to disk
        final String content = big.extractBytesToRAM(result.positionStart);
        
        // output to screen
        text.setText(content);
        // place the text back on top
        text.setCaretPosition(0);
        
        System.out.println("Loaded " + result.filename);
    }

    /**
     * React whenever the user wants to start a search
     */
    private void doSearchMouseClicked() {
        String currentTerm = search.getText();
        if(currentTerm.equals(searchTerm)){
            search.setText("");
            System.out.println("Reset the search box");
            //searchReset();
            if(hasKeywordSearch){
                hasKeywordSearch = false;
                keywordSearch = null;
                text.setText("");
                displayContents();
            }
        }
    }
    
    
     /**
     * Interprets the keys being pressed on the search box
     * @param evt the keystroke
     */
    private void performSearch(KeyEvent evt) {
        // people expect to press "ESC" to clear the whole bar
        if(evt.getKeyCode() == KeyEvent.VK_ESCAPE){
            search.transferFocus();
            //System.err.println("SU00 - Pressed ESCAPE on search box");
            search.setText(searchTerm);
            searchReset();
            return;
        }
        
        // ENTER means that we are serious about the current search term
        if(evt.getKeyCode() == KeyEvent.VK_ENTER){
            launchSearch();
            return;
        } 

        // if the box is empty and someone presses backspace, then do nothing
        Boolean emptyBox = search.getText().isEmpty();
        Boolean backspacePressed = evt.getKeyCode() == KeyEvent.VK_BACK_SPACE;
        if((emptyBox)&&(backspacePressed)){
            // the result is empty, but make sure we clean up the results box
            text.setText("");
            return;
        }
        
        
        // there is a bug that allows people to write over the "search" default
        if(search.getText().isEmpty()){
            searchReset();
            return;
        }
        
        
        
        // there is a bug that allows people to write over the "search" default
        if(search.getText().startsWith(searchTerm)){
            String temp = search.getText().replace(searchTerm, "");
            search.setText(temp);
        }
    }

    /**
     * Launching a search for a given file
     */
    private void launchSearch() {
        System.out.println("V560: Launch a search");
        text.setText("Showing the results of the search on the treeview."
                + "\n\n"
                + "To view the full treeview, remove the search terms."
                + "");
        
        // enable the search
        hasKeywordSearch = true;
        keywordSearch = search.getText().toLowerCase();
        
        // process all files again
        displayContents();
    }
    

    private void searchReset() {
        if(search.getText().isEmpty()){
            search.setText("Search files..");
            hasKeywordSearch = false;
            keywordSearch = null;
            System.out.println("Restoring all results on treeview");
            // process all files again
            displayContents();
        }
    }

    /**
     * Saves a file to disk
     */
    private void saveSelectedFile() {
        // get the tree node
        DefaultMutableTreeNode treeNode = (DefaultMutableTreeNode) tree.getSelectionPath().getLastPathComponent();
        BigNode result = (BigNode) treeNode.getUserObject();
        // prepare the file
        File output = result.getExtractedFile();
        // save the text from the window to the file
        utils.files.SaveStringToFile(output, text.getText());
        
        try {
            JOptionPane.showMessageDialog(this, "Saved content to " + output.getCanonicalPath());
        } catch (IOException ex) {
            Logger.getLogger(view.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    
    
    
}


// the object that we will store on the treeview
class BigNode{
        final Long
                positionStart;
        public Long
                positionEnd;
        final String 
                signature,
                filename;
        // Create the node
        BigNode(final long position, final String signature, final String filename){
            this.positionStart = position;
            this.signature = signature;
            this.filename = filename;
        }
        
        /**
         * Used after downloading a big file
         * @return The pointer the file on disk
         */
        File getExtractedFile(){
            String lastName = filename.substring(filename.lastIndexOf("/")+1);
            return new File(lastName);
        }
        
        @Override
        public String toString(){
            return filename;
        }
}