/*
 * SPDXVersion: SPDX-1.1
 * Creator: Person: Nuno Brito (nuno.brito@triplecheck.de)
 * Creator: Organization: TripleCheck (contact@triplecheck.de)
 * Created: 2014-10-08T00:00:00Z
 * LicenseName: EUPL-1.1-without-appendix
 * FileName: view.java
 * FileType: SOURCE
 * FileCopyrightText: <text> Copyright 2013 Nuno Brito, TripleCheck </text>
 * FileComment: <text> The GUI for users to view the contents of big zips.
   </text>
 */

package big;

import java.awt.Color;
import java.awt.Toolkit;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.net.URL;
import javax.swing.JFileChooser;
import javax.swing.UIManager;
import javax.swing.UnsupportedLookAndFeelException;
import javax.swing.filechooser.FileFilter;
import javax.swing.filechooser.FileNameExtensionFilter;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;

/**
 *
 * @author Nuno Brito, 08th of October 2014 in Darmstadt, Germany.
 */
public class view extends javax.swing.JFrame {

    // the settings for the last folder/file that was open
    static final String lastFolderFilename = "last-folder.txt";
    static final File lastFolder = new File(lastFolderFilename);
    private int counter;
    private ArchiveBIG big;
    private DefaultTreeModel model;
    private DefaultMutableTreeNode root;
        
    
    /**
     * Creates new form view
     */
    public view() {
        initComponents();
        
         // adopt the default user interface menus and buttons
        try {
            UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
        } catch (ClassNotFoundException ex) {} catch (IllegalAccessException ex) {
        } catch (InstantiationException ex) {
        } catch (UnsupportedLookAndFeelException ex) {
        }
        
        // get the window icon working
        URL imgURL = this.getClass().getResource("logo.png");
        setIconImage(Toolkit.getDefaultToolkit().getImage(imgURL));
        
        this.setTitle("bigzip");
        
        // place the frame on the middle of the screen
        setLocationRelativeTo(null);
        
        // change the background to full white
        getContentPane().setBackground( Color.WHITE );
        
        // opens a big zip as first operation
        openFile();
        
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jSplitPane1 = new javax.swing.JSplitPane();
        panelWest = new javax.swing.JScrollPane();
        tree = new javax.swing.JTree();
        panelEast = new javax.swing.JPanel();
        jScrollPane2 = new javax.swing.JScrollPane();
        jPanel3 = new javax.swing.JPanel();
        text = new javax.swing.JEditorPane();
        search = new javax.swing.JTextField();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jSplitPane1.setBorder(null);
        jSplitPane1.setDividerLocation(200);

        panelWest.setAutoscrolls(true);
        panelWest.setPreferredSize(new java.awt.Dimension(172, 362));

        tree.setBorder(javax.swing.BorderFactory.createEmptyBorder(3, 2, 5, 5));
        javax.swing.tree.DefaultMutableTreeNode treeNode1 = new javax.swing.tree.DefaultMutableTreeNode("root");
        tree.setModel(new javax.swing.tree.DefaultTreeModel(treeNode1));
        tree.setAutoscrolls(true);
        tree.setLargeModel(true);
        tree.setRootVisible(false);
        tree.setRowHeight(18);
        tree.setToggleClickCount(1);
        tree.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                treeeventTreeMouseClicked(evt);
            }
        });
        panelWest.setViewportView(tree);

        jSplitPane1.setLeftComponent(panelWest);

        jScrollPane2.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);
        jScrollPane2.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);

        text.setEditable(false);
        text.setMinimumSize(new java.awt.Dimension(10, 23));
        text.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                textFocusGained(evt);
            }
            public void focusLost(java.awt.event.FocusEvent evt) {
                textFocusLost(evt);
            }
        });
        text.addPropertyChangeListener(new java.beans.PropertyChangeListener() {
            public void propertyChange(java.beans.PropertyChangeEvent evt) {
                textPropertyChange(evt);
            }
        });
        text.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyTyped(java.awt.event.KeyEvent evt) {
                textKeyTyped(evt);
            }
        });

        javax.swing.GroupLayout jPanel3Layout = new javax.swing.GroupLayout(jPanel3);
        jPanel3.setLayout(jPanel3Layout);
        jPanel3Layout.setHorizontalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(text, javax.swing.GroupLayout.DEFAULT_SIZE, 475, Short.MAX_VALUE)
        );
        jPanel3Layout.setVerticalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(text, javax.swing.GroupLayout.DEFAULT_SIZE, 358, Short.MAX_VALUE)
        );

        jScrollPane2.setViewportView(jPanel3);

        search.setFont(new java.awt.Font("Arial", 0, 14)); // NOI18N
        search.setText("Search..");
        search.setMargin(new java.awt.Insets(2, 8, 2, 2));
        search.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                searchFocusGained(evt);
            }
            public void focusLost(java.awt.event.FocusEvent evt) {
                searchFocusLost(evt);
            }
        });
        search.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                searchdoSearchKeypress(evt);
            }
            public void keyReleased(java.awt.event.KeyEvent evt) {
                searchdoSearch(evt);
            }
        });

        javax.swing.GroupLayout panelEastLayout = new javax.swing.GroupLayout(panelEast);
        panelEast.setLayout(panelEastLayout);
        panelEastLayout.setHorizontalGroup(
            panelEastLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, panelEastLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(search)
                .addContainerGap())
            .addComponent(jScrollPane2)
        );
        panelEastLayout.setVerticalGroup(
            panelEastLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(panelEastLayout.createSequentialGroup()
                .addGap(5, 5, 5)
                .addComponent(search, javax.swing.GroupLayout.PREFERRED_SIZE, 34, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(11, 11, 11)
                .addComponent(jScrollPane2))
        );

        jSplitPane1.setRightComponent(panelEast);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jSplitPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 674, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jSplitPane1)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void treeeventTreeMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_treeeventTreeMouseClicked
        getSelectedTreeNode();
    }//GEN-LAST:event_treeeventTreeMouseClicked

    private void textFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_textFocusGained

    }//GEN-LAST:event_textFocusGained

    private void textFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_textFocusLost

    }//GEN-LAST:event_textFocusLost

    private void textPropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_textPropertyChange

    }//GEN-LAST:event_textPropertyChange

    private void textKeyTyped(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_textKeyTyped

    }//GEN-LAST:event_textKeyTyped

    private void searchFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_searchFocusGained
    }//GEN-LAST:event_searchFocusGained

    private void searchFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_searchFocusLost
       
    }//GEN-LAST:event_searchFocusLost

    private void searchdoSearchKeypress(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_searchdoSearchKeypress

    }//GEN-LAST:event_searchdoSearchKeypress

    private void searchdoSearch(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_searchdoSearch
    }//GEN-LAST:event_searchdoSearch

     /**
     * Shows the dialog to allow selecting a folder 
     */
    public void chooseFolder(){
        
        // read the last folder that was chosen
        File lastFile = getLastFile();
        
        
        JFileChooser fc = new JFileChooser();
            fc.setMultiSelectionEnabled(false);
            
            FileNameExtensionFilter filter = new FileNameExtensionFilter(
                "BIG archive", "big");
            
            
            fc.setFileFilter(filter);
            // only show directories
            fc.setFileSelectionMode(JFileChooser.OPEN_DIALOG);
            
            // check if the last used folder still exists
            if(lastFile.exists())
            if((lastFile.getParentFile().exists())){
                // start from the previous folder if possible
//                fc.setCurrentDirectory(lastFile.getParentFile());
                fc.setSelectedFile(lastFile);
            }

        fc.setDialogTitle("Open directory");
        // open up the dialog
        if (fc.showOpenDialog(null) != JFileChooser.APPROVE_OPTION) {
            System.exit(0);
            return;
        }
        
       
        // write this name to the file on disk
        utils.files.SaveStringToFile(lastFolder, fc.getSelectedFile().getAbsolutePath());
    }
    
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                new view().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel jPanel3;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JSplitPane jSplitPane1;
    private javax.swing.JPanel panelEast;
    private javax.swing.JScrollPane panelWest;
    private javax.swing.JTextField search;
    private javax.swing.JEditorPane text;
    private javax.swing.JTree tree;
    // End of variables declaration//GEN-END:variables

    /**
     * Opens up the "File Open" dialog to choose a big zip.
     */
    private void openFile() {
        // show the open file dialog
        chooseFolder();
        // show the file contents
        displayContents();
    }

    /**
     * Returns a file pointer to the last file that was used
     * @return The file pointer on disk or null if nothing was selected.
     */
    public File getLastFile(){
    // read the last folder that was chosen
        String lastFileText = utils.files.readAsString(lastFolder);
        File lastFile = new File(lastFileText);
        return lastFile;
    }
    
    /**
     * Get the index file associated with the big archive
     * @return 
     */
     public File getLastFileIndex(){
    // read the last folder that was chosen
        String lastFileText = utils.files.readAsString(lastFolder);
        File lastFile = new File(lastFileText);
        return lastFile;
    }
    
    /**
     * Creates a treeview with the contents from the big file
     */
    private void displayContents() {
        // get the last file that was open
        File lastFile = getLastFile();
        // no need to continue if the file is null for some odd reason
        if(lastFile == null){
            return;
        }
        
        // open up the big archive
        big = new ArchiveBIG(lastFile);
        
        File indexFile = big.getFileIndex();
        // check if the file for index does exist
        if(indexFile == null){
            return;
        }
        
        doSettings();
        processLines(big);
        doFinish();
    }

    /**
     * Extract the data that we find interesting to show
     * @param line 
     */
    private void processLine(final String line) {
       // we expect a line on the following format:
       //000000026039957 4b7b96a4c76fb230ac055cad145dbbfb346a5663 /github.com/trankas/opentesarenapp/WinArena/World.cpp
       
        // cut the string into pieces
        final String 
                signature = line.substring(16, 56),
                filename  = line.substring(57);
        // convert the long number
        final Long position = Long.parseLong(line.substring(00, 15));
        // create the node
        final BigNode node = new BigNode(position, signature, filename);
        // add it up to the tree view listing
        root.add(new DefaultMutableTreeNode(node));
    }

    /**
     * The small settings related to the file being processed
     */
    private void doSettings() {
        File file = getLastFile();
        this.setTitle(file.getName());
        // get the tree object
        model = (DefaultTreeModel)tree.getModel();
        root = (DefaultMutableTreeNode)model.getRoot();
        
        // this is needed to ensure we get line-wrapping
        jScrollPane2.setViewportView(text);
            
        
    }

    /**
     * Process the lines inside our archive
     * @param big 
     */
    private void processLines(ArchiveBIG big) {
        // list the contents
        BufferedReader reader;
        try {
            // open up the index file
            FileReader fileReader = new FileReader(big.getFileIndex());
            reader = new BufferedReader(fileReader);
            // avoid the signature line
            reader.readLine();
            // read the first line of data
            String line = reader.readLine();
            
            // iterate all lines?
            while (line != null) {
                // get this line of data handled
                processLine(line);
                // read the line afterwards
                line = reader.readLine();
                counter++;
            } 
        
        }catch (Exception e){
            System.err.println("V413 - Something went wrong while reading the archive");
        }
        
    }

    /**
     * Final settings after loading a big archive
     */
    private void doFinish() {
        // change the window title
        this.setTitle(big.getFile().getName() 
                + " ("
                + utils.text.pluralize(counter, "file")
                + ", "
                + utils.files.humanReadableSize(big.getFile().length())
                + ")"
        );
        
        // reload the treeview
        model.reload(root);
    }

    /**
     * This method is triggered when the user clicks on the tree view
     */
    private synchronized void getSelectedTreeNode() {
        DefaultMutableTreeNode treeNode = (DefaultMutableTreeNode) tree.getSelectionPath().getLastPathComponent();
        if(treeNode == null){
            return;
        }
        // get the associated object
        BigNode result = (BigNode) treeNode.getUserObject();
        processClick(result);
    }

    /**
     * Process the result from he click on the treeview
     * @param result 
     */
    private void processClick(final BigNode result) {
        // avoid null results
        if(result == null){
            return;
        }
        
        // define which file we want to delete
        File temp = new File("temp.bin");
        // extract the file to disk
        big.getFile(result.filename, temp);
        
        // define the target file
        File targetFile = result.getExtractedFile();
        // delete the temp file if available
        
        System.out.println("Extracted file to " + targetFile.getAbsolutePath());
        // read the contents
        final String content = utils.files.readAsString(targetFile);
        // output to screen
        text.setText(content);
        // place the text back on top
        text.setCaretPosition(0);
        
        if(targetFile.exists()){
            targetFile.delete();
        }
        
        
        
        System.out.println("Loaded " + result.filename);
    }
}


// the object that we will store on the treeview
class BigNode{
        final Long
                position;
        final String 
                signature,
                filename;
        // Create the node
        BigNode(final long position, final String signature, final String filename){
            this.position = position;
            this.signature = signature;
            this.filename = filename;
        }
        
        /**
         * Used after downloading a big file
         * @return The pointer the file on disk
         */
        File getExtractedFile(){
            String lastName = filename.substring(filename.lastIndexOf("/")+1);
            return new File(lastName);
        }
        
        @Override
        public String toString(){
            return filename;
        }
}